name: ðŸ§  Load Workshop Content

on:
  workflow_dispatch:
    inputs:
      environment:
        description: Target Cloudflare environment
        required: true
        default: production
        type: choice
        options:
          - production
          - preview
      workshops:
        description:
          Optional comma/newline-separated workshop slugs. Leave empty to index
          all.
        required: false
        default: ''
      batchSize:
        description: Workshops processed per request (1-20)
        required: false
        default: 5
        type: number

permissions:
  contents: read

jobs:
  load-workshop-content:
    name: ðŸ§  Reindex workshops into D1 + Vectorize
    runs-on: ubuntu-latest
    concurrency:
      group: workshop-content-load-${{ inputs.environment }}
      cancel-in-progress: false
    timeout-minutes: 45
    steps:
      - name: ðŸ“¦ Checkout
        uses: actions/checkout@v4

      - name: ðŸ”Ž Resolve target environment URL
        id: target
        env:
          TARGET_ENVIRONMENT: ${{ inputs.environment }}
          APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          set -euo pipefail

          WRANGLER_CONFIG_PATH="wrangler.jsonc"
          if [ ! -f "$WRANGLER_CONFIG_PATH" ]; then
            echo "Missing $WRANGLER_CONFIG_PATH in repo root. Ensure checkout ran." >&2
            exit 1
          fi

          WRANGLER_CONFIG_JSON="$(
            node - "$WRANGLER_CONFIG_PATH" <<'NODE'
const fs = require("fs");
const path = process.argv[1];
const raw = fs.readFileSync(path, "utf8");
const stripped = raw
  .replace(/\/\*[\s\S]*?\*\//g, "")
  .replace(/^\s*\/\/.*$/gm, "")
  .replace(/,\s*([}\]])/g, "$1");
const data = JSON.parse(stripped);
process.stdout.write(JSON.stringify(data));
NODE
          )"

          BASE_WORKER_NAME="$(printf '%s' "$WRANGLER_CONFIG_JSON" | jq -r '.name // empty')"
          if [ -z "$BASE_WORKER_NAME" ]; then
            echo "Unable to read .name from $WRANGLER_CONFIG_PATH." >&2
            exit 1
          fi

          PRODUCTION_WORKER_NAME="$(printf '%s' "$WRANGLER_CONFIG_JSON" | jq -r '.env.production.name // empty')"
          if [ -z "$PRODUCTION_WORKER_NAME" ]; then
            PRODUCTION_WORKER_NAME="${BASE_WORKER_NAME}-production"
          fi

          PREVIEW_WORKER_NAME="$(printf '%s' "$WRANGLER_CONFIG_JSON" | jq -r '.env.preview.name // empty')"
          if [ -z "$PREVIEW_WORKER_NAME" ]; then
            PREVIEW_WORKER_NAME="${BASE_WORKER_NAME}-preview"
          fi

          APP_BASE_URL_TRIMMED="$(printf '%s' "${APP_BASE_URL:-}" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
          APP_BASE_URL_TRIMMED="${APP_BASE_URL_TRIMMED%/}"

          SUBDOMAIN=""
          if [ -n "${CLOUDFLARE_API_TOKEN:-}" ] && [ -n "${CLOUDFLARE_ACCOUNT_ID:-}" ]; then
            if ! SUBDOMAIN="$(
              curl --silent --show-error \
                --request GET \
                --url "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/workers/subdomain" \
                --header "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                --header 'Content-Type: application/json' \
                | jq -r '.result.subdomain // empty'
            )"; then
              SUBDOMAIN=""
            fi
          fi

          DERIVED_URL=""
          if [ "$TARGET_ENVIRONMENT" = "preview" ]; then
            if [ -z "$SUBDOMAIN" ]; then
              if [ -z "${CLOUDFLARE_API_TOKEN:-}" ] || [ -z "${CLOUDFLARE_ACCOUNT_ID:-}" ]; then
                echo "Missing CLOUDFLARE_API_TOKEN or CLOUDFLARE_ACCOUNT_ID secret (required to determine preview URL)." >&2
              else
                echo "Unable to resolve workers.dev subdomain from Cloudflare API." >&2
              fi
              exit 1
            fi
            DERIVED_URL="https://${PREVIEW_WORKER_NAME}.${SUBDOMAIN}.workers.dev"
          elif [ -n "$SUBDOMAIN" ]; then
            DERIVED_URL="https://${PRODUCTION_WORKER_NAME}.${SUBDOMAIN}.workers.dev"
          fi

          CANDIDATES=()
          if [ -n "$DERIVED_URL" ]; then
            CANDIDATES+=("$DERIVED_URL")
          fi
          if [ "$TARGET_ENVIRONMENT" = "production" ] && [ -n "$APP_BASE_URL_TRIMMED" ]; then
            if [ "$APP_BASE_URL_TRIMMED" != "$DERIVED_URL" ]; then
              CANDIDATES+=("$APP_BASE_URL_TRIMMED")
            fi
          fi

          if [ "${#CANDIDATES[@]}" -eq 0 ]; then
            echo "Unable to resolve target URL (missing APP_BASE_URL and unable to compute workers.dev URL)." >&2
            exit 1
          fi

          # Preflight: the reindex route returns 401 (Unauthorized) when the Worker
          # is configured with a token but the request omits Authorization. If we
          # get 503, we're hitting a Worker that isn't configured for manual
          # reindexing yet (often due to targeting the wrong Worker name/URL).
          TARGET_URL=""
          PREFLIGHT_SUMMARY=""
          for candidate in "${CANDIDATES[@]}"; do
            candidate_trimmed="$(printf '%s' "$candidate" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
            candidate_trimmed="${candidate_trimmed%/}"
            if [ -z "$candidate_trimmed" ]; then
              continue
            fi
            if ! printf '%s' "$candidate_trimmed" | grep -Eq '^https?://'; then
              PREFLIGHT_SUMMARY="${PREFLIGHT_SUMMARY}\n- ${candidate_trimmed}: invalid URL (must start with http:// or https://)"
              continue
            fi

            RESPONSE_FILE="$(mktemp)"
            HTTP_STATUS="$(curl --silent --show-error \
              --retry 2 \
              --retry-all-errors \
              --retry-delay 1 \
              --connect-timeout 10 \
              --max-time 30 \
              --output "$RESPONSE_FILE" \
              --write-out '%{http_code}' \
              --request POST \
              --url "$candidate_trimmed/internal/workshop-index/reindex" \
              || true
            )"

            RESPONSE_BODY="$(<"$RESPONSE_FILE")"
            rm -f "$RESPONSE_FILE"

            if [ -z "${HTTP_STATUS:-}" ]; then
              HTTP_STATUS="000"
            fi

            ERROR_MESSAGE=""
            if printf '%s' "$RESPONSE_BODY" | jq -e . >/dev/null 2>&1; then
              ERROR_MESSAGE="$(printf '%s' "$RESPONSE_BODY" | jq -r '.error // empty' 2>/dev/null || true)"
            fi

            if [ "$HTTP_STATUS" = "401" ]; then
              TARGET_URL="$candidate_trimmed"
              break
            fi

            if [ -n "$ERROR_MESSAGE" ]; then
              PREFLIGHT_SUMMARY="${PREFLIGHT_SUMMARY}\n- ${candidate_trimmed}: HTTP ${HTTP_STATUS} (${ERROR_MESSAGE})"
            else
              PREFLIGHT_SUMMARY="${PREFLIGHT_SUMMARY}\n- ${candidate_trimmed}: HTTP ${HTTP_STATUS}"
            fi
          done

          if [ -z "$TARGET_URL" ]; then
            echo "Unable to find a target URL with reindex enabled/configured." >&2
            echo "" >&2
            echo "Tried:" >&2
            printf '%b\n' "$PREFLIGHT_SUMMARY" >&2
            echo "" >&2
            echo "If the Worker responds with 503 (token not configured), ensure the deploy workflow has synced WORKSHOP_INDEX_ADMIN_TOKEN to the Worker you're calling." >&2
            exit 1
          fi

          echo "target_url=$TARGET_URL" >> "$GITHUB_OUTPUT"

      - name: ðŸ” Verify admin token
        env:
          WORKSHOP_INDEX_ADMIN_TOKEN: ${{ secrets.WORKSHOP_INDEX_ADMIN_TOKEN }}
        run: |
          set -euo pipefail

          if [ -z "$WORKSHOP_INDEX_ADMIN_TOKEN" ]; then
            echo "Missing WORKSHOP_INDEX_ADMIN_TOKEN secret." >&2
            exit 1
          fi

      - name: ðŸšš Load workshop content into D1 and Vectorize
        env:
          TARGET_URL: ${{ steps.target.outputs.target_url }}
          WORKSHOP_INDEX_ADMIN_TOKEN: ${{ secrets.WORKSHOP_INDEX_ADMIN_TOKEN }}
          WORKSHOP_LIST_INPUT: ${{ inputs.workshops }}
          TARGET_ENVIRONMENT: ${{ inputs.environment }}
          WORKSHOP_BATCH_SIZE: ${{ inputs.batchSize }}
        run: |
          set -euo pipefail

          BATCH_SIZE_RAW="$(printf '%s' "${WORKSHOP_BATCH_SIZE:-5}" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
          if [ -z "$BATCH_SIZE_RAW" ]; then
            BATCH_SIZE_RAW="5"
          fi

          # GitHub `workflow_dispatch` number inputs may arrive like "5.0".
          BATCH_SIZE="$(
            jq -nr --arg value "$BATCH_SIZE_RAW" '
              try ($value | tonumber) catch empty
              | if (.|floor) == . then (.|floor) else empty end
            '
          )"
          if [ -z "$BATCH_SIZE" ]; then
            echo "batchSize must be a whole number between 1 and 20 (received: $BATCH_SIZE_RAW)." >&2
            exit 1
          fi
          if [ "$BATCH_SIZE" -lt 1 ] || [ "$BATCH_SIZE" -gt 20 ]; then
            echo "batchSize must be between 1 and 20 (received: $BATCH_SIZE)." >&2
            exit 1
          fi

          if [ -n "$WORKSHOP_LIST_INPUT" ]; then
            WORKSHOPS_JSON=$(printf '%s' "$WORKSHOP_LIST_INPUT" | jq -R -s 'gsub("[\\r\\n]+"; ",") | split(",") | map(gsub("^\\s+|\\s+$"; "")) | map(ascii_downcase) | map(select(length > 0)) | unique')
            WORKSHOP_COUNT_INPUT=$(printf '%s' "$WORKSHOPS_JSON" | jq -r 'length')
            if [ "$WORKSHOP_COUNT_INPUT" -gt 100 ]; then
              echo "workshops input must contain at most 100 unique slugs after normalization." >&2
              exit 1
            fi
            if [ "$WORKSHOP_COUNT_INPUT" -gt 0 ]; then
              BASE_PAYLOAD=$(jq -nc --argjson workshops "$WORKSHOPS_JSON" '{ workshops: $workshops }')
            else
              BASE_PAYLOAD='{}'
            fi
          else
            BASE_PAYLOAD='{}'
          fi

          TOTAL_WORKSHOP_COUNT=0
          TOTAL_EXERCISE_COUNT=0
          TOTAL_STEP_COUNT=0
          TOTAL_SECTION_COUNT=0
          TOTAL_SECTION_CHUNK_COUNT=0
          RUN_IDS=""
          NEXT_CURSOR=""
          ITERATION=0

          while true; do
            ITERATION=$((ITERATION + 1))
            if [ "$ITERATION" -gt 250 ]; then
              echo "Exceeded maximum pagination iterations while indexing." >&2
              exit 1
            fi

            PAYLOAD=$(
              printf '%s' "$BASE_PAYLOAD" | jq -c \
                --arg cursor "$NEXT_CURSOR" \
                --argjson batchSize "$BATCH_SIZE" \
                '. + { batchSize: $batchSize } + (if (($cursor | length) > 0) then { cursor: $cursor } else {} end)'
            )
            PAYLOAD_SIZE=${#PAYLOAD}
            if [ "$PAYLOAD_SIZE" -gt 50000 ]; then
              echo "Normalized reindex payload exceeds the 50000-character route limit." >&2
              exit 1
            fi

            RESPONSE_FILE=$(mktemp)
            HTTP_STATUS=$(
              curl --silent --show-error \
                --retry 3 \
                --retry-all-errors \
                --retry-delay 2 \
                --connect-timeout 15 \
                --max-time 300 \
                --output "$RESPONSE_FILE" \
                --write-out '%{http_code}' \
                --request POST \
                --url "$TARGET_URL/internal/workshop-index/reindex" \
                --header "Authorization: Bearer $WORKSHOP_INDEX_ADMIN_TOKEN" \
                --header 'Content-Type: application/json' \
                --data "$PAYLOAD"
            )

            RESPONSE_BODY=$(<"$RESPONSE_FILE")
            echo "Reindex response (iteration $ITERATION): $RESPONSE_BODY"

            if ! printf '%s' "$RESPONSE_BODY" | jq -e . >/dev/null; then
              echo "Workshop content load returned non-JSON response." >&2
              exit 1
            fi

            if [ "$HTTP_STATUS" != "200" ]; then
              ERROR_MESSAGE=$(printf '%s' "$RESPONSE_BODY" | jq -r '.error // "unknown error"')
              ERROR_DETAILS=$(printf '%s' "$RESPONSE_BODY" | jq -r '
                if (.details | type) == "array" then
                  (.details | map(tostring) | join("; "))
                elif (.details | type) == "string" then
                  .details
                else
                  ""
                end
              ')
              if [ -n "$ERROR_DETAILS" ]; then
                echo "Workshop content load failed with HTTP $HTTP_STATUS: $ERROR_MESSAGE ($ERROR_DETAILS)" >&2
              else
                echo "Workshop content load failed with HTTP $HTTP_STATUS: $ERROR_MESSAGE" >&2
              fi
              exit 1
            fi

            RESPONSE_OK=$(printf '%s' "$RESPONSE_BODY" | jq -r '.ok // false')
            if [ "$RESPONSE_OK" != "true" ]; then
              ERROR_MESSAGE=$(printf '%s' "$RESPONSE_BODY" | jq -r '.error // "unknown error"')
              ERROR_DETAILS=$(printf '%s' "$RESPONSE_BODY" | jq -r '
                if (.details | type) == "array" then
                  (.details | map(tostring) | join("; "))
                elif (.details | type) == "string" then
                  .details
                else
                  ""
                end
              ')
              if [ -n "$ERROR_DETAILS" ]; then
                echo "Workshop content load reported failure: $ERROR_MESSAGE ($ERROR_DETAILS)" >&2
              else
                echo "Workshop content load reported failure: $ERROR_MESSAGE" >&2
              fi
              exit 1
            fi

            WORKSHOP_COUNT=$(printf '%s' "$RESPONSE_BODY" | jq -r '.workshopCount // 0')
            EXERCISE_COUNT=$(printf '%s' "$RESPONSE_BODY" | jq -r '.exerciseCount // 0')
            STEP_COUNT=$(printf '%s' "$RESPONSE_BODY" | jq -r '.stepCount // 0')
            SECTION_COUNT=$(printf '%s' "$RESPONSE_BODY" | jq -r '.sectionCount // 0')
            SECTION_CHUNK_COUNT=$(printf '%s' "$RESPONSE_BODY" | jq -r '.sectionChunkCount // 0')
            RUN_ID=$(printf '%s' "$RESPONSE_BODY" | jq -r '.runId // "unknown"')

            TOTAL_WORKSHOP_COUNT=$((TOTAL_WORKSHOP_COUNT + WORKSHOP_COUNT))
            TOTAL_EXERCISE_COUNT=$((TOTAL_EXERCISE_COUNT + EXERCISE_COUNT))
            TOTAL_STEP_COUNT=$((TOTAL_STEP_COUNT + STEP_COUNT))
            TOTAL_SECTION_COUNT=$((TOTAL_SECTION_COUNT + SECTION_COUNT))
            TOTAL_SECTION_CHUNK_COUNT=$((TOTAL_SECTION_CHUNK_COUNT + SECTION_CHUNK_COUNT))

            if [ -z "$RUN_IDS" ]; then
              RUN_IDS="$RUN_ID"
            else
              RUN_IDS="$RUN_IDS, $RUN_ID"
            fi

            NEXT_CURSOR=$(printf '%s' "$RESPONSE_BODY" | jq -r '.nextCursor // empty')
            if [ -z "$NEXT_CURSOR" ]; then
              break
            fi

            sleep 2
          done

          REQUESTED_WORKSHOPS=$(printf '%s' "$BASE_PAYLOAD" | jq -r '.workshops // [] | join(", ")')

          {
            echo "## Workshop content load complete"
            echo ""
            echo "- Environment: $TARGET_ENVIRONMENT"
            echo "- Target URL: $TARGET_URL"
            echo "- Batch size: $BATCH_SIZE"
            if [ -n "$REQUESTED_WORKSHOPS" ]; then
              echo "- Requested workshops: $REQUESTED_WORKSHOPS"
            else
              echo "- Requested workshops: all discovered workshop repositories"
            fi
            echo "- Reindex run ids: $RUN_IDS"
            echo "- Workshop count: $TOTAL_WORKSHOP_COUNT"
            echo "- Exercise count: $TOTAL_EXERCISE_COUNT"
            echo "- Step count: $TOTAL_STEP_COUNT"
            echo "- Section count: $TOTAL_SECTION_COUNT"
            echo "- Section chunk count: $TOTAL_SECTION_CHUNK_COUNT"
          } >> "$GITHUB_STEP_SUMMARY"
